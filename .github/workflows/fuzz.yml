name: Fuzz

on:
  pull_request:
    paths:
      - "fuzz/**"
      - "src/**"
      - ".github/workflows/fuzz.yml"
      - "Cargo.lock"
      - "Cargo.toml"
      - "package-lock.json"
  schedule:
    # Run nightly at 3:00 UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      fuzz_duration:
        description: 'Fuzz duration in seconds per target'
        required: false
        default: '300'
      target:
        description: 'Specific target to fuzz (leave empty for all)'
        required: false
        default: ''

env:
  CARGO_TERM_COLOR: always
  # Fuzz duration: 5 minutes per target for scheduled runs
  FUZZ_DURATION: ${{ github.event_name == 'pull_request' && '60' || github.event.inputs.fuzz_duration || '300' }}
  FUZZ_SANITIZER: address

jobs:
  fuzz:
    name: Fuzz ${{ matrix.target }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write      # For cache save
      issues: write       # For creating issues on crash
    strategy:
      fail-fast: false
      matrix:
        target:
          - decode_from_buffer
          - pipeline_ops
          - inspect_header
          - encode_to_format
          - icc_profile
          - batch_concurrent
          - firewall_bypass
          - metrics_processing
          - streaming_pipeline
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust nightly
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: llvm-tools-preview

      - name: Install cargo-fuzz
        run: cargo install cargo-fuzz --locked

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake nasm clang lld

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            fuzz/target
          key: fuzz-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            fuzz-${{ runner.os }}-

      - name: Download corpus
        continue-on-error: true
        uses: actions/cache@v4
        with:
          path: fuzz/corpus/${{ matrix.target }}
          key: corpus-${{ matrix.target }}-${{ github.run_id }}
          restore-keys: |
            corpus-${{ matrix.target }}-

      - name: Create seed corpus
        run: |
          mkdir -p fuzz/corpus/${{ matrix.target }}
          # Add minimal seed files if corpus is empty
          if [ -z "$(ls -A fuzz/corpus/${{ matrix.target }} 2>/dev/null)" ]; then
            cp -r fuzz/seeds/* fuzz/corpus/${{ matrix.target }}/ 2>/dev/null || true
          fi

      - name: Build fuzzer
        if: ${{ github.event_name == 'schedule' || github.event.inputs.target == '' || github.event.inputs.target == matrix.target }}
        env:
          RUSTFLAGS: "-Zsanitizer=address"
          ASAN_OPTIONS: "detect_leaks=1:abort_on_error=1:malloc_context_size=15"
        run: |
          cd fuzz
          cargo +nightly fuzz build --sanitizer=${FUZZ_SANITIZER} ${{ matrix.target }}

      - name: Run fuzzer
        if: ${{ github.event_name == 'schedule' || github.event.inputs.target == '' || github.event.inputs.target == matrix.target }}
        env:
          RUSTFLAGS: "-Zsanitizer=address"
          ASAN_OPTIONS: "detect_leaks=1:abort_on_error=1:malloc_context_size=15"
        run: |
          cd fuzz
          # Strict 2GB RSS cap for all targets. decode_from_buffer stays under it
          # via fuzz-time decode caps (FUZZ_MAX_DIMENSION / FUZZ_MAX_PIXELS) in the engine.
          RSS_LIMIT_MB=2048
          # Run with memory limit (2GB) and length limit (1MB)
          # Timeout applies only to fuzzer execution, not build time
          timeout ${FUZZ_DURATION}s cargo +nightly fuzz run --sanitizer=${FUZZ_SANITIZER} ${{ matrix.target }} -- \
            -max_len=1048576 \
            -rss_limit_mb=${RSS_LIMIT_MB} \
            -max_total_time=${FUZZ_DURATION} \
            || EXIT_CODE=$?
          # Exit codes that indicate successful completion:
          #   0 = normal completion (no crashes found)
          #  77 = libFuzzer reached max_total_time (expected - means no crashes in time limit)
          # 124 = timeout command terminated after time limit (expected - means no crashes in time limit)
          # Any other exit code indicates a real failure (crash, memory error, etc.)
          if [ "${EXIT_CODE:-0}" != "0" ] && [ "${EXIT_CODE:-0}" != "77" ] && [ "${EXIT_CODE:-0}" != "124" ]; then
            exit $EXIT_CODE
          fi

      - name: Save corpus
        if: always()
        uses: actions/cache/save@v4
        with:
          path: fuzz/corpus/${{ matrix.target }}
          key: corpus-${{ matrix.target }}-${{ github.run_id }}

      - name: Upload crash artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: crash-${{ matrix.target }}
          path: |
            fuzz/artifacts/${{ matrix.target }}
          if-no-files-found: ignore

  report:
    name: Fuzz Report
    needs: fuzz
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: read
      issues: write       # For creating issues on crash
    steps:
      - name: Download all crash artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: crash-*
          merge-multiple: true
          path: crashes
        continue-on-error: true

      - name: Check for crashes
        id: check_crashes
        run: |
          if [ -d crashes ] && [ "$(ls -A crashes 2>/dev/null)" ]; then
            echo "has_crashes=true" >> $GITHUB_OUTPUT
            echo "::error::Fuzzing found crashes!"
            ls -la crashes/
          else
            echo "has_crashes=false" >> $GITHUB_OUTPUT
            echo "No crashes found"
          fi

      - name: Create issue on crash
        if: steps.check_crashes.outputs.has_crashes == 'true' && github.event_name != 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let crashes = [];
            try {
              crashes = fs.readdirSync('crashes').filter(f => !f.startsWith('.'));
            } catch (e) {
              console.log('No crashes directory found');
              return;
            }

            if (crashes.length > 0) {
              // Check if similar issue already exists
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'fuzz-crash'
              });

              const existingIssue = issues.data.find(i =>
                i.title.includes('[Fuzz] Crash detected')
              );

              if (existingIssue) {
                // Add comment to existing issue
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existingIssue.number,
                  body: `## New Crash Report\n\nAdditional crashes found in: ${crashes.join(', ')}\n\nSee [workflow run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.`
                });
              } else {
                // Create new issue
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[Fuzz] Crash detected in nightly fuzzing`,
                  body: `## Fuzzing Crash Report\n\nCrashes found in: ${crashes.join(', ')}\n\nSee [workflow run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.\n\n### Next Steps\n1. Download the crash artifacts from the workflow run\n2. Reproduce locally: \`cargo +nightly fuzz run <target> <crash_file>\`\n3. Fix the issue and add a regression test`,
                  labels: ['bug', 'security', 'fuzz-crash']
                });
              }
            }

      - name: Fail if crashes found
        if: steps.check_crashes.outputs.has_crashes == 'true'
        run: exit 1
