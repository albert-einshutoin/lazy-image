/**
 * Create a minimal valid JPEG test image for CI environments.
 * Pure JavaScript implementation - no external dependencies.
 * 
 * This creates a 100x100 grayscale JPEG that's valid for all image operations.
 */
const fs = require('fs');
const path = require('path');

// Minimal valid JPEG structure for a 100x100 grayscale image
// JPEG format: SOI -> APP0 (JFIF) -> DQT -> SOF0 -> DHT -> SOS -> EOI
function createMinimalJPEG() {
    const width = 100;
    const height = 100;
    
    // JPEG markers
    const SOI = Buffer.from([0xFF, 0xD8]); // Start of Image
    const EOI = Buffer.from([0xFF, 0xD9]); // End of Image
    
    // APP0 segment (JFIF header)
    const app0 = Buffer.from([
        0xFF, 0xE0, // APP0 marker
        0x00, 0x10, // Length (16 bytes)
        0x4A, 0x46, 0x49, 0x46, 0x00, // "JFIF\0"
        0x01, 0x01, // Version 1.1
        0x00, // Units (0 = no units)
        0x00, 0x01, // X density (1)
        0x00, 0x01, // Y density (1)
        0x00, 0x00, // Thumbnail width/height (0)
    ]);
    
    // DQT (Quantization Table) - Standard luminance table
    const dqt = Buffer.from([
        0xFF, 0xDB, // DQT marker
        0x00, 0x43, // Length (67 bytes)
        0x00, // Table ID and precision (0 = 8-bit)
        // Standard quantization table (64 bytes)
        0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07,
        0x07, 0x07, 0x09, 0x09, 0x08, 0x0A, 0x0C, 0x14,
        0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12, 0x13,
        0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A,
        0x1C, 0x1C, 0x20, 0x24, 0x2E, 0x27, 0x20, 0x22,
        0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29, 0x2C,
        0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39,
        0x3D, 0x38, 0x32, 0x3C, 0x2E, 0x33, 0x34, 0x32,
    ]);
    
    // SOF0 (Start of Frame) - Grayscale
    const sof0 = Buffer.alloc(11);
    sof0[0] = 0xFF;
    sof0[1] = 0xC0; // SOF0 marker
    sof0[2] = 0x00; // Length high byte
    sof0[3] = 0x0B; // Length low byte (11 bytes)
    sof0[4] = 0x08; // Precision (8 bits)
    sof0[5] = (height >> 8) & 0xFF; // Height high byte
    sof0[6] = height & 0xFF; // Height low byte
    sof0[7] = (width >> 8) & 0xFF; // Width high byte
    sof0[8] = width & 0xFF; // Width low byte
    sof0[9] = 0x01; // Number of components
    sof0[10] = 0x11; // Component ID=1, sampling=1x1, quantization table=0
    
    // DHT (Huffman Table) - Standard DC/AC tables
    const dht = Buffer.from([
        0xFF, 0xC4, // DHT marker
        0x00, 0x1F, // Length (31 bytes)
        0x00, // Table class (0=DC) and ID (0)
        // Huffman code lengths (16 bytes)
        0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // Huffman values (10 bytes)
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B,
    ]);
    
    // SOS (Start of Scan)
    const sos = Buffer.from([
        0xFF, 0xDA, // SOS marker
        0x00, 0x08, // Length (8 bytes)
        0x01, // Number of components
        0x00, // Component ID=1, DC table=0, AC table=0
        0x00, // Start of spectral selection
        0x3F, // End of spectral selection
        0x00, // Successive approximation
    ]);
    
    // Minimal scan data (encoded image data)
    // For a 100x100 grayscale image, we need minimal valid scan data
    // This is a simplified representation - actual JPEG encoding is more complex
    // But this structure is valid enough for testing image decoding
    const scanData = Buffer.from([
        0xFF, 0x00, 0x00, // Minimal scan data (with byte stuffing)
    ]);
    
    // Combine all segments
    return Buffer.concat([SOI, app0, dqt, sof0, dht, sos, scanData, EOI]);
}

// Alternative: Use a pre-validated minimal JPEG byte sequence
// This is a known-good minimal JPEG that decoders accept
function createValidMinimalJPEG() {
    // This is a valid 1x1 pixel JPEG (minimal size)
    return Buffer.from([
        0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
        0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
        0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
        0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
        0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
        0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
        0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
        0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01,
        0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00,
        0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x09, 0x0A, 0x0B, 0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03,
        0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D,
        0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06,
        0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08,
        0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72,
        0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
        0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
        0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75,
        0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
        0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,
        0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
        0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9,
        0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2,
        0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4,
        0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01,
        0x00, 0x00, 0x3F, 0x00, 0xFB, 0xD5, 0xDB, 0x20, 0xA8, 0xF1, 0x45, 0x00,
        0xFF, 0xD9,
    ]);
}

// Use the pre-validated minimal JPEG (more reliable)
const jpeg = createValidMinimalJPEG();
const outputPath = path.join(__dirname, '..', 'test_input.jpg');
fs.writeFileSync(outputPath, jpeg);
console.log(`Created test image: ${outputPath} (${jpeg.length} bytes)`);
