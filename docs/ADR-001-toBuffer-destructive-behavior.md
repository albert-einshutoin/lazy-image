# ADR-001: toBuffer()の破壊的動作について

## ステータス

提案中

## コンテキスト

現在の`toBuffer()`は内部で`self.source.take()`を呼び出し、ソースを消費するため、同一エンジンインスタンスからの複数回の呼び出しができない。

```rust
pub fn to_buffer(...) -> Result<AsyncTask<EncodeTask>> {
    let source = self.source.take();  // ここでソースが消費される
    // ...
}
```

これにより以下の混乱が発生：

```javascript
const engine = ImageEngine.from(buffer);
const jpeg = await engine.toBuffer('jpeg');  // OK
const webp = await engine.toBuffer('webp');  // エラー: "no image source"
```

この問題は、v1.0リリース前に解決すべき重要な設計判断である。

## 決定

**選択肢2: 非破壊化**を採用する。

`toBuffer()`を非破壊的に変更し、内部で自動的に`clone()`を実行する。これにより、同一エンジンインスタンスから複数回の呼び出しが可能になる。

## 選択肢

### 選択肢1: 現状維持（破壊的）

**メリット**:
- メモリ効率が最良（ソースデータのコピーが不要）
- 大容量画像処理での明示的なメモリ解放
- 実装がシンプル（現在の実装を維持）

**デメリット**:
- 直感に反する動作（多くのユーザーが複数回呼び出しを期待）
- `clone()`の使用が必須となり、APIの使いやすさが低下
- エラーメッセージが不親切（"no image source"は原因が分かりにくい）

**他ライブラリ**: 
- **sharp**: 破壊的（`toBuffer()`を呼ぶとパイプラインが終了し、再度呼ぶとエラー。`clone()`が必要）
- **jimp**: `toBuffer()`自体は非破壊的だが、他の操作（`resize()`、`rotate()`など）は破壊的。`clone()`が必要

**メモリ効率への影響**:
- ソースデータは`Arc<Vec<u8>>`で保持されているため、`clone()`しても参照カウントが増えるだけで、実際のデータコピーは発生しない
- ただし、`decoded`画像（`DynamicImage`）は完全にクローンされる必要がある
- 大容量画像（例: 50MP）の場合、デコード済み画像のクローンはメモリを2倍消費する可能性がある

### 選択肢2: 非破壊化

**メリット**:
- 直感的なAPI（複数回呼び出し可能）
- 複数フォーマット出力が容易（`engine.toBuffer('jpeg')`と`engine.toBuffer('webp')`を連続で呼び出せる）
- ユーザーエクスペリエンスが向上（`clone()`を意識する必要がない）
- sharp/jimpと比較して使いやすい

**デメリット**:
- 暗黙の`clone()`によるメモリ増加
- 大容量画像で問題になる可能性（ただし、`source`は`Arc`なので影響は限定的）
- `decoded`画像が存在する場合、完全なクローンが必要

**他ライブラリ**: 
- **sharp**: 破壊的だが、`clone()`が明示的で分かりやすい
- **jimp**: `toBuffer()`は非破壊的だが、操作自体が破壊的

**メモリ効率への影響**:
- `source: Arc<Vec<u8>>`のクローンは参照カウントのみ増加（データコピーなし）
- `decoded: Option<DynamicImage>`のクローンは完全なコピーが必要
- ただし、`decoded`は`toBuffer()`呼び出し時に`take()`されるため、2回目以降の呼び出しでは再デコードが必要
- 実際のメモリ増加は、`decoded`が存在する場合のみ発生（通常は`None`）

**実装方針**:
```rust
pub fn to_buffer(...) -> Result<AsyncTask<EncodeTask>> {
    let output_format = OutputFormat::from_str(&format, quality)
        .map_err(Error::from_reason)?;

    // 非破壊化: clone()を使用してソースを保持
    let source = self.source.clone();
    let decoded = self.decoded.clone();
    let ops = self.ops.clone();
    let icc_profile = self.icc_profile.clone();

    Ok(AsyncTask::new(EncodeTask {
        source,
        decoded,
        ops,
        format: output_format,
        icc_profile,
    }))
}
```

### 選択肢3: 両方提供

**メリット**:
- ユーザーが選択可能（柔軟性）
- 移行期間を設けられる
- メモリ効率を重視するユーザーは`consumeToBuffer()`を使用可能

**デメリット**:
- API表面積の増加（2つのメソッドを維持する必要がある）
- どちらを使うべきか迷う（選択の負担）
- ドキュメントとサンプルコードの複雑化
- メンテナンスコストの増加

**他ライブラリ**: 
- このアプローチを採用している主要ライブラリは見当たらない

**メモリ効率への影響**:
- 選択肢1と2の影響が混在

## 比較表

| 項目 | 選択肢1: 現状維持 | 選択肢2: 非破壊化 | 選択肢3: 両方提供 |
|------|------------------|------------------|------------------|
| **APIの直感性** | ❌ 低い（`clone()`必須） | ✅ 高い | ⚠️ 中程度（選択が必要） |
| **メモリ効率** | ✅ 最良 | ⚠️ 良好（`Arc`により影響は限定的） | ⚠️ 良好（選択次第） |
| **使いやすさ** | ❌ 低い | ✅ 高い | ⚠️ 中程度 |
| **実装の複雑さ** | ✅ シンプル | ✅ シンプル | ❌ 複雑 |
| **メンテナンス性** | ✅ 高い | ✅ 高い | ❌ 低い |
| **他ライブラリとの一貫性** | ⚠️ sharpと同様 | ✅ より使いやすい | ❌ 独自アプローチ |
| **ドキュメントの複雑さ** | ⚠️ `clone()`の説明が必要 | ✅ シンプル | ❌ 2つのメソッドを説明 |

## 結論

**選択肢2: 非破壊化**を採用する。

### 理由

1. **ユーザーエクスペリエンスの向上**: 
   - 複数フォーマット出力は一般的なユースケース（例: JPEGとWebPの両方を生成）
   - `clone()`を意識せずに使えるAPIは、lazy-imageの「使いやすさ」の目標に合致

2. **メモリ効率への影響は限定的**:
   - `source`は`Arc<Vec<u8>>`で保持されているため、クローンしても参照カウントのみ増加
   - `decoded`は通常`None`であり、存在する場合でも`toBuffer()`呼び出し時に`take()`されるため、2回目以降は再デコードが必要（メモリ増加は一時的）

3. **sharp/jimpとの差別化**:
   - sharpは破壊的だが、`clone()`が明示的で分かりやすい
   - lazy-imageは非破壊的で、より使いやすいAPIを提供できる

4. **実装のシンプルさ**:
   - `take()`を`clone()`に変更するだけで実装可能
   - 追加のメソッドや複雑なロジックが不要

5. **v1.0前の決定**:
   - v1.0でAPIを凍結する前に、この重要な設計判断を確定させる必要がある

### 実装時の注意点

1. **`decoded`の扱い**:
   - `decoded`が存在する場合、完全なクローンが必要（メモリ増加）
   - ただし、通常は`None`であり、`toBuffer()`呼び出し時に`take()`されるため、2回目以降は再デコードが必要
   - この動作は許容範囲内と判断

2. **エラーメッセージ**:
   - 現在の"no image source"エラーは発生しなくなる
   - ただし、`source`が`None`の場合（理論上は発生しないが）のエラーハンドリングは維持

3. **後方互換性**:
   - 破壊的から非破壊的への変更は、既存コードを壊す可能性がある
   - ただし、現在の動作は「バグ」と見なされる可能性が高く、非破壊化は「修正」として扱える
   - マイナーバージョンアップ（0.x → 0.y）で実施可能

## 影響

### コード変更

- `src/engine.rs`: `toBuffer()`, `toBufferWithMetrics()`, `toFile()`の`take()`を`clone()`に変更
- テスト: 複数回呼び出しのテストケースを追加

### ドキュメント更新

- README: `toBuffer()`が非破壊的であることを明記
- サンプルコード: 複数フォーマット出力の例を追加

### 移行ガイド

- 既存コードで`clone()`を使用している場合は、不要になることを明記
- ただし、パフォーマンスを最重視する場合は、引き続き`clone()`を使用可能（メモリ効率の観点から）

## 参考

- [sharp documentation](https://sharp.pixelplumbing.com/)
- [jimp documentation](https://jimp-dev.github.io/jimp/)
- [ADR Template](https://adr.github.io/)
