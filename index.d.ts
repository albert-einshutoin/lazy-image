/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface Dimensions {
  width: number
  height: number
}
/** Image metadata returned by inspect() */
export interface ImageMetadata {
  /** Image width in pixels */
  width: number
  /** Image height in pixels */
  height: number
  /** Detected format (jpeg, png, webp, gif, etc.) */
  format?: string
}
/**
 * Inspect image metadata WITHOUT decoding pixels.
 * This reads only the header bytes - extremely fast (<1ms).
 *
 * Use this to check dimensions before processing, or to reject
 * images that are too large without wasting CPU on decoding.
 */
export declare function inspect(buffer: Buffer): ImageMetadata
/**
 * Inspect image metadata from a file path WITHOUT loading into Node.js heap.
 * **Memory-efficient**: Reads directly from filesystem, bypassing V8 entirely.
 * This is the recommended way for server-side metadata inspection.
 */
export declare function inspectFile(path: string): ImageMetadata
/** Get library version */
export declare function version(): string
/** Get supported input formats */
export declare function supportedInputFormats(): Array<string>
/** Get supported output formats */
export declare function supportedOutputFormats(): Array<string>
/**
 * The main image processing engine.
 *
 * Usage:
 * ```js
 * const result = await ImageEngine.from(buffer)
 *   .resize(800)
 *   .rotate(90)
 *   .grayscale()
 *   .toBuffer('jpeg', 75);
 * ```
 */
export declare class ImageEngine {
  /**
   * Create engine from a buffer. Decoding is lazy.
   * Extracts ICC profile from the source image if present.
   */
  static from(buffer: Buffer): ImageEngine
  /**
   * Create engine from a file path.
   * **Memory-efficient**: Reads directly into Rust heap, bypassing Node.js V8 heap.
   * This is the recommended way for server-side processing of large images.
   */
  static fromPath(path: string): ImageEngine
  /** Create a clone of this engine (for multi-output scenarios) */
  clone(): ImageEngine
  /** Resize image. Width or height can be null to maintain aspect ratio. */
  resize(width?: number | undefined | null, height?: number | undefined | null): ImageEngine
  /** Crop a region from the image. */
  crop(x: number, y: number, width: number, height: number): ImageEngine
  /** Rotate by degrees (90, 180, 270 only) */
  rotate(degrees: number): ImageEngine
  /** Flip horizontally */
  flipH(): ImageEngine
  /** Flip vertically */
  flipV(): ImageEngine
  /** Convert to grayscale */
  grayscale(): ImageEngine
  /** Adjust brightness (-100 to 100) */
  brightness(value: number): ImageEngine
  /** Adjust contrast (-100 to 100) */
  contrast(value: number): ImageEngine
  /**
   * Encode to buffer asynchronously.
   * format: "jpeg", "jpg", "png", "webp"
   * quality: 1-100 (default 80, ignored for PNG)
   */
  toBuffer(format: string, quality?: number | undefined | null): Promise<unknown>
  /**
   * Encode and write directly to a file asynchronously.
   * **Memory-efficient**: Combined with fromPath(), this enables
   * full file-to-file processing without touching Node.js heap.
   *
   * Returns the number of bytes written.
   */
  toFile(path: string, format: string, quality?: number | undefined | null): Promise<unknown>
  /** Get image dimensions (decodes image if needed) */
  dimensions(): Dimensions
  /**
   * Check if an ICC color profile was extracted from the source image.
   * Returns the profile size in bytes, or null if no profile exists.
   */
  hasIccProfile(): number | null
}
