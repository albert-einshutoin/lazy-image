/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * The main image processing engine.
 *
 * Usage:
 * ```js
 * const result = await ImageEngine.from(buffer)
 *   .resize(800)
 *   .rotate(90)
 *   .grayscale()
 *   .toBuffer('jpeg', 75);
 * ```
 */
export declare class ImageEngine {
  /**
   * Create engine from a buffer. Decoding is lazy.
   * Extracts ICC profile and EXIF metadata from the source image if present.
   */
  static from(buffer: Buffer): ImageEngine
  /**
   * Create engine from a file path.
   * **ZERO-COPY MEMORY MAPPING**: Uses mmap to map the file into memory.
   * This enables true zero-copy access - OS pages in only what's needed.
   * This is the recommended way for server-side processing of large images.
   */
  static fromPath(path: string): ImageEngine
  /** Create a clone of this engine (for multi-output scenarios) */
  clone(): ImageEngine
  /**
   * Resize image. Width or height can be null to maintain aspect ratio.
   * When both width and height are provided, `fit` controls behavior:
   * - "inside" (default): maintain aspect ratio and fit within the box
   * - "cover": maintain aspect ratio and crop to fill the box
   * - "fill": ignore aspect ratio and force exact dimensions
   */
  resize(width?: number | undefined | null, height?: number | undefined | null, fit?: string | undefined | null): ImageEngine
  /** Crop a region from the image. */
  crop(x: number, y: number, width: number, height: number): ImageEngine
  /** Rotate by degrees (90, 180, 270 only) */
  rotate(degrees: number): ImageEngine
  /** Flip horizontally */
  flipH(): ImageEngine
  /** Flip vertically */
  flipV(): ImageEngine
  /** Convert to grayscale */
  grayscale(): ImageEngine
  /**
   * Enable or disable EXIF auto-orientation (default: enabled).
   * `true` = apply EXIF Orientation automatically (sharp-compatible)
   * `false` = ignore EXIF Orientation
   */
  autoOrient(enabled: boolean): ImageEngine
  /**
   * Preserve metadata in output.
   * - ICC profile: Preserved when `icc: true` (default when options provided)
   * - EXIF: Preserved when `exif: true`. Orientation is auto-reset to 1 after auto-orient.
   * - GPS: Stripped by default when `stripGps: true` (privacy-first, exceeds Sharp)
   * - XMP: Not yet supported (emits warning)
   *
   * By default, all metadata is stripped for security and smaller file sizes.
   */
  keepMetadata(options?: KeepMetadataOptions | undefined | null): ImageEngine
  /**
   * Enable Image Firewall mode with built-in policies (strict or lenient).
   * Strict mode enforces aggressive limits and rejects dangerous metadata (best for zero-trust inputs).
   * Lenient mode keeps generous limits but still guards against decompression bombs.
   */
  sanitize(options?: SanitizeOptions | undefined | null): ImageEngine
  /**
   * Override Image Firewall limits (maxPixels, maxBytes, timeoutMs).
   * Any field set to 0 disables that particular limit.
   */
  limits(options: FirewallLimitOptions): ImageEngine
  /** Adjust brightness (-100 to 100) */
  brightness(value: number): ImageEngine
  /** Adjust contrast (-100 to 100) */
  contrast(value: number): ImageEngine
  /**
   * Normalize pixel format to RGB/RGBA without performing any color space transformation.
   * This does not apply ICC profile conversion; it only guarantees the pixel layout is RGB/RGBA.
   * Use a dedicated color management library for true color space conversions.
   */
  normalizePixelFormat(): ImageEngine
  /**
   * Deprecated: Use `normalizePixelFormat` instead. Scheduled for removal in v1.0.0.
   * Kept for backward compatibility; behavior is identical to `normalizePixelFormat`.
   */
  ensureRgb(): ImageEngine
  /**
   * Apply a built-in preset for common use cases.
   *
   * Available presets:
   * - "thumbnail": 150x150, WebP quality 75 (gallery thumbnails)
   * - "avatar": 200x200, WebP quality 80 (profile pictures)
   * - "hero": 1920 width, JPEG quality 85 (hero images, banners)
   * - "social": 1200x630, JPEG quality 80 (OGP/Twitter cards)
   *
   * Returns the preset configuration for use with toBuffer/toFile.
   */
  preset(name: string): PresetResult
  /**
   * Encode to buffer asynchronously.
   * format: "jpeg", "jpg", "png", "webp", "avif"
   * quality: 1-100 (default: JPEG=85, WebP=80, AVIF=60, ignored for PNG)
   * fastMode: If true, uses faster encoding for JPEG (2-4x faster, slightly larger files). Default: false.
   *
   * **Non-destructive**: This method can be called multiple times on the same engine instance.
   * The source data is cloned internally, allowing multiple format outputs.
   */
  toBuffer(format: string, quality?: number | undefined | null, fastMode?: boolean | undefined | null): Promise<Buffer>
  /**
   * Convenience: encode using the last applied preset by name.
   * Equivalent to calling `preset(name)` then `toBuffer(preset.format, preset.quality)`.
   */
  toBufferWithPreset(presetName: string): Promise<Buffer>
  /**
   * Encode to buffer asynchronously with performance metrics.
   * Returns `{ data: Buffer, metrics: ProcessingMetrics }`.
   *
   * **Non-destructive**: This method can be called multiple times on the same engine instance.
   * The source data is cloned internally, allowing multiple format outputs.
   */
  toBufferWithMetrics(format: string, quality?: number | undefined | null, fastMode?: boolean | undefined | null): Promise<OutputWithMetrics>
  /**
   * Convenience: encode with metrics using a preset name.
   * Equivalent to `preset(name)` then `toBufferWithMetrics(preset.format, preset.quality)`.
   */
  toBufferWithMetricsPreset(presetName: string): Promise<OutputWithMetrics>
  /**
   * Encode and write directly to a file asynchronously.
   * **Memory-efficient**: Combined with fromPath(), this enables
   * full file-to-file processing without touching Node.js heap.
   *
   * **Non-destructive**: This method can be called multiple times on the same engine instance.
   * The source data is cloned internally, allowing multiple format outputs.
   *
   * Returns the number of bytes written.
   */
  toFile(path: string, format: string, quality?: number | undefined | null, fastMode?: boolean | undefined | null): Promise<number>
  /** Convenience: encode to file using the preset's recommended format/quality. */
  toFileWithPreset(path: string, presetName: string): Promise<number>
  /**
   * Get image dimensions WITHOUT full decoding.
   * For file paths, reads only the header bytes (extremely fast).
   * For in-memory buffers, uses header-only parsing.
   */
  dimensions(): Dimensions
  /**
   * Check if an ICC color profile was extracted from the source image.
   * Returns the profile size in bytes, or null if no profile exists.
   */
  hasIccProfile(): number | null
  /**
   * Process multiple images in parallel with the same operations.
   *
   * - inputs: Array of input file paths
   * - output_dir: Directory to write processed images
   * - options: Output settings
   *   - format: Output format ("jpeg", "png", "webp", "avif")
   *   - quality: Optional quality (1-100, uses format-specific default if None)
   *   - fastMode: Optional fast mode flag (only applies to JPEG, default: false)
   *   - concurrency: Optional number of parallel workers:
   *     - 0 or undefined: Auto-detect based on CPU cores and memory limits (smart concurrency)
   *       Detects container memory limits (cgroup v1/v2) and adjusts to prevent OOM kills.
   *       Ideal for serverless/containerized environments with memory constraints.
   *     - 1-1024: Manual override - use specified number of concurrent operations
   *
   * Backward compatibility: the legacy positional signature
   *   processBatch(inputs, outputDir, format, quality?, fastMode?, concurrency?)
   * is still accepted for now but will be removed in a future major release.
   */
  processBatch(inputs: Array<string>, outputDir: string, optionsOrFormat: BatchOptions | string, quality?: number | undefined | null, fastMode?: boolean | undefined | null, concurrency?: number | undefined | null): Promise<BatchResult[]>
}

export interface BatchOptions {
  /** Output format ("jpeg", "png", "webp", "avif") */
  format: string
  /** Optional quality (1-100), uses format default when omitted */
  quality?: number
  /** Optional fast mode flag (JPEG only, default: false) */
  fastMode?: boolean
  /**
   * Optional number of parallel workers:
   * 0/undefined = auto-detect, 1-1024 = manual override
   */
  concurrency?: number
}

export interface BatchResult {
  source: string
  success: boolean
  error?: string
  outputPath?: string
  errorCode?: string
  errorCategory?: ErrorCategory
}

export interface Dimensions {
  width: number
  height: number
}

/**
 * Error taxonomy for proper error handling in JavaScript
 *
 * This 4-tier taxonomy enables proper error handling:
 * - UserError: Invalid input, recoverable by user
 * - CodecError: Format/encoding issues
 * - ResourceLimit: Memory/time/dimension limits
 * - InternalBug: Library bugs (should not happen)
 */
export declare const enum ErrorCategory {
  /** Invalid input, recoverable by user */
  UserError = 0,
  /** Format/encoding issues */
  CodecError = 1,
  /** Memory/time/dimension limits */
  ResourceLimit = 2,
  /** Library bugs (should not happen) */
  InternalBug = 3
}

/**
 * Fine-grained error codes for diagnostics and recovery guidance.
 *
 * Ranges:
 * - E1xx: Input errors
 * - E2xx: Processing/operation errors
 * - E3xx: Output errors
 * - E4xx: Configuration errors
 * - E9xx: Internal errors
 */
export declare const enum ErrorCode {
  FileNotFound = 100,
  FileReadFailed = 101,
  MmapFailed = 102,
  UnsupportedFormat = 111,
  CorruptedImage = 130,
  DecodeFailed = 131,
  DimensionExceedsLimit = 121,
  PixelCountExceedsLimit = 122,
  FirewallViolation = 123,
  InvalidCropBounds = 200,
  InvalidCropDimensions = 201,
  InvalidRotationAngle = 202,
  InvalidResizeDimensions = 203,
  InvalidResizeFit = 204,
  UnsupportedColorSpace = 210,
  ResizeFailed = 299,
  EncodeFailed = 300,
  FileWriteFailed = 301,
  InvalidArgument = 400,
  InvalidPreset = 401,
  InvalidFirewallPolicy = 402,
  SourceConsumed = 900,
  InternalPanic = 901,
  Generic = 999
}

export interface FirewallLimitOptions {
  maxPixels?: number
  maxBytes?: number
  timeoutMs?: number
}

/** Image metadata returned by inspect() */
export interface ImageMetadata {
  /** Image width in pixels */
  width: number
  /** Image height in pixels */
  height: number
  /** Detected format (jpeg, png, webp, gif, etc.) */
  format?: string
}

/**
 * Inspect image metadata WITHOUT decoding pixels.
 * This reads only the header bytes - extremely fast (<1ms).
 *
 * Use this to check dimensions before processing, or to reject
 * images that are too large without wasting CPU on decoding.
 */
export declare function inspect(buffer: Buffer): ImageMetadata

/**
 * Inspect image metadata from a file path WITHOUT loading into Node.js heap.
 * **Memory-efficient**: Reads directly from filesystem, bypassing V8 entirely.
 * This is the recommended way for server-side metadata inspection.
 */
export declare function inspectFile(path: string): ImageMetadata

export interface KeepMetadataOptions {
  /** Preserve ICC profile (default: true when options are provided) */
  icc?: boolean
  /**
   * Preserve EXIF metadata (camera info, settings, etc.)
   * Note: Orientation tag is automatically reset to 1 after auto-orient
   */
  exif?: boolean
  /** XMP preservation is not implemented yet (will emit runtime warning when requested) */
  xmp?: boolean
  /**
   * Strip GPS/location tags from EXIF (default: true for privacy protection)
   * This is a security-first default that exceeds Sharp's capabilities
   */
  stripGps?: boolean
}

export interface OutputWithMetrics {
  data: Buffer
  metrics: ProcessingMetrics
}

/** Result of applying a preset and encoding to buffer */
export interface PresetBufferResult {
  /** Encoded image data */
  data: Buffer
  /** Recommended output format */
  format: string
  /** Recommended quality (None for PNG) */
  quality?: number
  /** Target width (None if aspect ratio preserved) */
  width?: number
  /** Target height (None if aspect ratio preserved) */
  height?: number
}

/** Result of applying a preset, contains recommended output settings */
export interface PresetResult {
  /** Recommended output format */
  format: string
  /** Recommended quality (None for PNG) */
  quality?: number
  /** Target width (None if aspect ratio preserved) */
  width?: number
  /** Target height (None if aspect ratio preserved) */
  height?: number
}

/** Processing metrics for performance monitoring */
export interface ProcessingMetrics {
  /** Schema version for compatibility negotiation */
  version: string
  /** Decode stage duration in milliseconds */
  decodeMs: number
  /** Ops (transform) stage duration in milliseconds */
  opsMs: number
  /** Encode stage duration in milliseconds */
  encodeMs: number
  /** Total wall-clock duration in milliseconds */
  totalMs: number
  /**
   * Peak memory usage during processing (RSS, bytes, as u32 for NAPI compatibility)
   *
   * **Note**: On Linux/macOS, this uses `ru_maxrss` from `getrusage()`, which represents
   * the cumulative maximum RSS of the entire process, not just this operation.
   * This is a limitation of the `getrusage()` API. For accurate per-operation memory tracking,
   * consider using process-specific memory profiling tools.
   */
  peakRss: number
  /** Total CPU time (user + system) in seconds */
  cpuTime: number
  /** Total processing time (wall clock) in seconds (legacy seconds field) */
  processingTime: number
  /** Input file size in bytes (as u32 for NAPI compatibility, max 4GB) */
  bytesIn: number
  /** Output file size in bytes (as u32 for NAPI compatibility, max 4GB) */
  bytesOut: number
  /** Compression ratio (bytes_out / bytes_in) */
  compressionRatio: number
  /** Detected input format (lowercase: jpeg, png, webp, avif, etc.) */
  formatIn?: string
  /** Output format */
  formatOut: string
  /** True when ICC profile was present and preserved */
  iccPreserved: boolean
  /** True when metadata was stripped (either by default or policy) */
  metadataStripped: boolean
  /** Non-fatal policy rejections (e.g., strict policy forcing metadata strip) */
  policyViolations: Array<string>
  /** Time taken to decode the image (milliseconds) - legacy alias of decode_ms */
  decodeTime: number
  /** Time taken to apply all operations (milliseconds) - legacy alias of ops_ms */
  processTime: number
  /** Time taken to encode the image (milliseconds) - legacy alias of encode_ms */
  encodeTime: number
  /** Peak memory usage during processing (RSS, bytes) - legacy alias of peak_rss */
  memoryPeak: number
  /** Input size legacy alias (bytes_in) */
  inputSize: number
  /** Output size legacy alias (bytes_out) */
  outputSize: number
}

export interface SanitizeOptions {
  policy?: string
}

/** Get supported input formats */
export declare function supportedInputFormats(): Array<string>

/** Get supported output formats */
export declare function supportedOutputFormats(): Array<string>

/** Get library version */
export declare function version(): string
