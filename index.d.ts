/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Supported output formats for image encoding.
 * @see {@link ImageEngine.toBuffer}
 */
export type OutputFormat = 'jpeg' | 'jpg' | 'png' | 'webp' | 'avif';

/**
 * Supported input formats for image decoding.
 */
export type InputFormat = 'jpeg' | 'jpg' | 'png' | 'webp';

/**
 * Image dimensions.
 */
export interface Dimensions {
  /** Image width in pixels */
  width: number;
  /** Image height in pixels */
  height: number;
}

/**
 * Result of applying a preset.
 * Use with {@link ImageEngine.toBuffer} or {@link ImageEngine.toFile}.
 * 
 * @example
 * ```typescript
 * const preset = engine.preset('thumbnail');
 * const buffer = await engine.toBuffer(preset.format, preset.quality);
 * ```
 */
export interface PresetResult {
  /** Recommended output format */
  format: OutputFormat;
  /** 
   * Recommended quality (1-100).
   * `undefined` for PNG (lossless).
   */
  quality?: number;
  /** Target width in pixels. `undefined` if aspect ratio is preserved. */
  width?: number;
  /** Target height in pixels. `undefined` if aspect ratio is preserved. */
  height?: number;
}

/**
 * Result of batch processing operation.
 */
export interface BatchResult {
  /** Source file path */
  source: string;
  /** Whether the processing succeeded */
  success: boolean;
  /** Error message if failed */
  error?: string;
  /** Output file path if succeeded */
  outputPath?: string;
}

/**
 * Image metadata returned by {@link inspect} and {@link inspectFile}.
 */
export interface ImageMetadata {
  /** Image width in pixels */
  width: number;
  /** Image height in pixels */
  height: number;
  /** 
   * Detected format.
   * `null` if format could not be determined.
   */
  format: InputFormat | null;
}

/**
 * Performance metrics for image processing.
 * Returned by {@link ImageEngine.toBufferWithMetrics}.
 */
export interface ProcessingMetrics {
  /** Time taken to decode the image (milliseconds) */
  decodeTime: number;
  /** Time taken to apply all operations (milliseconds) */
  processTime: number;
  /** Time taken to encode the image (milliseconds) */
  encodeTime: number;
  /** Peak memory usage during processing (bytes) */
  memoryPeak: number;
}

/**
 * Output with performance metrics.
 * Returned by {@link ImageEngine.toBufferWithMetrics}.
 */
export interface OutputWithMetrics {
  /** Encoded image data */
  data: Buffer;
  /** Performance metrics */
  metrics: ProcessingMetrics;
}

/**
 * Inspect image metadata WITHOUT decoding pixels.
 * Reads only header bytes - extremely fast (<1ms).
 * 
 * Use this to check dimensions before processing, or to reject
 * images that are too large without wasting CPU on decoding.
 * 
 * @param buffer - Image data as Buffer
 * @returns Image metadata (width, height, format)
 * @throws If the buffer is not a valid image
 * 
 * @example
 * ```typescript
 * const meta = inspect(buffer);
 * if (meta.width > 4000) {
 *   throw new Error('Image too large');
 * }
 * ```
 */
export declare function inspect(buffer: Buffer): ImageMetadata;

/**
 * Inspect image metadata from a file path WITHOUT loading into Node.js heap.
 * 
 * **Memory-efficient**: Reads directly from filesystem, bypassing V8 entirely.
 * This is the recommended way for server-side metadata inspection.
 * 
 * @param path - Path to the image file
 * @returns Image metadata (width, height, format)
 * @throws If the file does not exist or is not a valid image
 * 
 * @example
 * ```typescript
 * const meta = inspectFile('/path/to/image.jpg');
 * console.log(`Image: ${meta.width}x${meta.height}, format: ${meta.format}`);
 * ```
 */
export declare function inspectFile(path: string): ImageMetadata;

/**
 * Get library version.
 * @returns Semantic version string (e.g., "0.7.8")
 */
export declare function version(): string;

/**
 * Get supported input formats.
 * @returns Array of supported format strings
 */
export declare function supportedInputFormats(): InputFormat[];

/**
 * Get supported output formats.
 * @returns Array of supported format strings
 */
export declare function supportedOutputFormats(): OutputFormat[];

/**
 * The main image processing engine.
 * 
 * Provides a fluent API for image manipulation with lazy evaluation.
 * Operations are queued and executed only when output is requested.
 * 
 * @example Basic usage
 * ```typescript
 * const result = await ImageEngine.from(buffer)
 *   .resize(800)
 *   .rotate(90)
 *   .grayscale()
 *   .toBuffer('jpeg', 75);
 * ```
 * 
 * @example Multi-output with clone
 * ```typescript
 * const engine = ImageEngine.from(buffer).resize(800);
 * const [jpeg, webp] = await Promise.all([
 *   engine.clone().toBuffer('jpeg', 85),
 *   engine.clone().toBuffer('webp', 80),
 * ]);
 * ```
 * 
 * @example Memory-efficient file processing
 * ```typescript
 * const bytesWritten = await ImageEngine.fromPath('input.jpg')
 *   .resize(800)
 *   .toFile('output.jpg', 'jpeg', 80);
 * ```
 */
export declare class ImageEngine {
  /**
   * Create engine from a Buffer.
   * Decoding is lazy - happens only when needed.
   * 
   * @param buffer - Image data as Buffer
   * @returns New ImageEngine instance
   * 
   * @remarks
   * This loads the buffer into Node.js heap. For large images or
   * server-side processing, prefer {@link ImageEngine.fromPath}.
   */
  static from(buffer: Buffer): ImageEngine;

  /**
   * Create engine from a file path.
   * 
   * **Memory-efficient**: Reads directly into Rust heap, bypassing Node.js V8 heap.
   * This is the recommended way for server-side processing of large images.
   * 
   * @param path - Path to the image file
   * @returns New ImageEngine instance
   * @throws If the file does not exist or cannot be read
   */
  static fromPath(path: string): ImageEngine;

  /**
   * Create a clone of this engine.
   * 
   * Use this for multi-output scenarios where you need to encode
   * the same processed image in multiple formats.
   * 
   * @returns Cloned ImageEngine instance
   * 
   * @example
   * ```typescript
   * const engine = ImageEngine.from(buffer).resize(800);
   * const jpeg = await engine.clone().toBuffer('jpeg');
   * const webp = await engine.clone().toBuffer('webp');
   * ```
   */
  clone(): ImageEngine;

  /**
   * Resize image.
   * 
   * If only width is specified, height is calculated to maintain aspect ratio.
   * If only height is specified, width is calculated to maintain aspect ratio.
   * If both are specified, image is resized to exact dimensions.
   * 
   * @param width - Target width in pixels. `null` to auto-calculate.
   * @param height - Target height in pixels. `null` to auto-calculate.
   * @returns `this` for method chaining
   * 
   * @example
   * ```typescript
   * // Resize to width 800, auto height
   * engine.resize(800, null);
   * 
   * // Resize to exact 800x600
   * engine.resize(800, 600);
   * ```
   */
  resize(width?: number | null, height?: number | null): ImageEngine;

  /**
   * Crop a region from the image.
   * 
   * @param x - Left offset in pixels
   * @param y - Top offset in pixels
   * @param width - Crop width in pixels
   * @param height - Crop height in pixels
   * @returns `this` for method chaining
   * @throws If crop bounds exceed image dimensions
   */
  crop(x: number, y: number, width: number, height: number): ImageEngine;

  /**
   * Rotate image by specified degrees.
   * 
   * @param degrees - Rotation angle. Only 0, 90, 180, 270 (and negatives) are supported.
   * @returns `this` for method chaining
   * @throws If degrees is not a supported angle
   */
  rotate(degrees: number): ImageEngine;

  /**
   * Flip image horizontally (mirror).
   * @returns `this` for method chaining
   */
  flipH(): ImageEngine;

  /**
   * Flip image vertically.
   * @returns `this` for method chaining
   */
  flipV(): ImageEngine;

  /**
   * Convert image to grayscale.
   * @returns `this` for method chaining
   */
  grayscale(): ImageEngine;

  /**
   * Adjust image brightness.
   * 
   * @param value - Brightness adjustment (-100 to 100).
   *   - Negative values darken the image
   *   - Positive values brighten the image
   *   - 0 has no effect
   * @returns `this` for method chaining
   */
  brightness(value: number): ImageEngine;

  /**
   * Adjust image contrast.
   * 
   * @param value - Contrast adjustment (-100 to 100).
   *   - Negative values decrease contrast
   *   - Positive values increase contrast
   *   - 0 has no effect
   * @returns `this` for method chaining
   */
  contrast(value: number): ImageEngine;

  /**
   * Convert to specific color space.
   * 
   * @param colorSpace - Target color space. Currently only `'srgb'` is fully supported.
   * @returns `this` for method chaining
   * @throws If color space is not supported
   */
  toColorspace(colorSpace: 'srgb' | 'p3' | 'adobergb'): ImageEngine;

  /**
   * Apply a built-in preset for common use cases.
   * 
   * This method applies resize operations and returns recommended
   * output settings for the preset.
   * 
   * **Available presets:**
   * 
   * - `thumbnail`: 150x150, WebP q75 (gallery thumbnails)
   * - `avatar`: 200x200, WebP q80 (profile pictures)
   * - `hero`: 1920 width, JPEG q85 (hero images, banners)
   * - `social`: 1200x630, JPEG q80 (OGP/Twitter cards)
   * 
   * @param name - Preset name
   * @returns Preset configuration for use with toBuffer/toFile
   * @throws If preset name is unknown
   * 
   * @example
   * ```typescript
   * const preset = engine.preset('thumbnail');
   * const buffer = await engine.toBuffer(preset.format, preset.quality);
   * ```
   */
  preset(name: 'thumbnail' | 'avatar' | 'hero' | 'social'): PresetResult;

  /**
   * Encode image to Buffer.
   * 
   * **Default quality by format:**
   * 
   * - JPEG: 85 (high quality, balanced file size)
   * - WebP: 80 (optimal for WebP compression)
   * - AVIF: 60 (AVIF's high efficiency means lower values still look great)
   * - PNG: N/A (lossless, quality parameter ignored)
   * 
   * @param format - Output format: `'jpeg'`, `'jpg'`, `'png'`, `'webp'`, or `'avif'`
   * @param quality - Quality level 1-100. Uses format-specific default if omitted.
   * @returns Promise resolving to encoded image Buffer
   * @throws If format is unsupported or encoding fails
   * 
   * @remarks
   * **Non-destructive**: This method can be called multiple times on the same engine instance.
   * The source data is cloned internally, allowing multiple format outputs.
   * 
   * @example
   * ```typescript
   * // Use default quality (85 for JPEG)
   * const jpeg = await engine.toBuffer('jpeg');
   * 
   * // Specify custom quality
   * const webp = await engine.toBuffer('webp', 90);
   * ```
   */
  toBuffer(format: OutputFormat, quality?: number | null): Promise<Buffer>;

  /**
   * Encode image to Buffer with performance metrics.
   * 
   * Same as {@link ImageEngine.toBuffer}, but also returns timing
   * and memory usage information.
   * 
   * @param format - Output format
   * @param quality - Quality level 1-100
   * @returns Promise resolving to encoded data and metrics
   * 
   * @remarks
   * **Non-destructive**: This method can be called multiple times on the same engine instance.
   * The source data is cloned internally, allowing multiple format outputs.
   * 
   * @example
   * ```typescript
   * const { data, metrics } = await engine.toBufferWithMetrics('jpeg', 80);
   * console.log(`Encode time: ${metrics.encodeTime}ms`);
   * ```
   */
  toBufferWithMetrics(format: OutputFormat, quality?: number | null): Promise<OutputWithMetrics>;

  /**
   * Encode and write directly to a file.
   * 
   * **Memory-efficient**: Combined with {@link ImageEngine.fromPath}, this enables
   * full file-to-file processing without touching Node.js heap.
   * 
   * @param path - Output file path
   * @param format - Output format
   * @param quality - Quality level 1-100
   * @returns Promise resolving to number of bytes written
   * @throws If encoding fails or file cannot be written
   * 
   * @remarks
   * **Non-destructive**: This method can be called multiple times on the same engine instance.
   * The source data is cloned internally, allowing multiple format outputs.
   * 
   * @example
   * ```typescript
   * const bytes = await ImageEngine.fromPath('input.png')
   *   .resize(800)
   *   .toFile('output.jpg', 'jpeg', 80);
   * console.log(`Wrote ${bytes} bytes`);
   * ```
   */
  toFile(path: string, format: OutputFormat, quality?: number | null): Promise<number>;

  /**
   * Get image dimensions.
   * 
   * @returns Image dimensions
   * @remarks This decodes the image if not already decoded.
   */
  dimensions(): Dimensions;

  /**
   * Check if an ICC color profile was extracted from the source image.
   * 
   * @returns Profile size in bytes, or `null` if no profile exists
   * 
   * @example
   * ```typescript
   * const iccSize = engine.hasIccProfile();
   * if (iccSize) {
   *   console.log(`ICC profile: ${iccSize} bytes`);
   * }
   * ```
   */
  hasIccProfile(): number | null;

  /**
   * Process multiple images in parallel with the same operations.
   * 
   * @param inputs - Array of input file paths
   * @param outputDir - Directory to write processed images
   * @param format - Output format
   * @param quality - Quality level 1-100 (uses format default if omitted)
   * @param concurrency - Number of parallel workers. 
   *   - `0` or `undefined`: Use CPU core count (default)
   *   - `1-1024`: Use specified number of workers
   * @returns Promise resolving to array of results
   * 
   * @example
   * ```typescript
   * const engine = ImageEngine.from(buffer).resize(800);
   * const results = await engine.processBatch(
   *   ['img1.jpg', 'img2.jpg', 'img3.jpg'],
   *   './output',
   *   'webp',
   *   80,
   *   4  // Use 4 parallel workers
   * );
   * results.forEach(r => {
   *   if (r.success) {
   *     console.log(`✅ ${r.source} → ${r.outputPath}`);
   *   } else {
   *     console.log(`❌ ${r.source}: ${r.error}`);
   *   }
   * });
   * ```
   */
  processBatch(
    inputs: string[],
    outputDir: string,
    format: OutputFormat,
    quality?: number | null,
    concurrency?: number | null
  ): Promise<BatchResult[]>;
}
